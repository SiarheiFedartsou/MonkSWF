/*File: Texture2D.mAbstract: Creates OpenGL 2D textures from images or text.Version: 1.8Disclaimer: IMPORTANT:  This Apple software is supplied to you by Apple Inc.("Apple") in consideration of your agreement to the following terms, and youruse, installation, modification or redistribution of this Apple softwareconstitutes acceptance of these terms.  If you do not agree with these terms,please do not use, install, modify or redistribute this Apple software.In consideration of your agreement to abide by the following terms, and subjectto these terms, Apple grants you a personal, non-exclusive license, underApple's copyrights in this original Apple software (the "Apple Software"), touse, reproduce, modify and redistribute the Apple Software, with or withoutmodifications, in source and/or binary forms; provided that if you redistributethe Apple Software in its entirety and without modifications, you must retainthis notice and the following text and disclaimers in all such redistributionsof the Apple Software.Neither the name, trademarks, service marks or logos of Apple Inc. may be usedto endorse or promote products derived from the Apple Software without specificprior written permission from Apple.  Except as expressly stated in this notice,no other rights or licenses, express or implied, are granted by Apple herein,including but not limited to any patent rights that may be infringed by yourderivative works or by other works in which the Apple Software may beincorporated.The Apple Software is provided by Apple on an "AS IS" basis.  APPLE MAKES NOWARRANTIES, EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION THE IMPLIEDWARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY AND FITNESS FOR A PARTICULARPURPOSE, REGARDING THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR INCOMBINATION WITH YOUR PRODUCTS.IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT, INCIDENTAL ORCONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTEGOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)ARISING IN ANY WAY OUT OF THE USE, REPRODUCTION, MODIFICATION AND/ORDISTRIBUTION OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY OFCONTRACT, TORT (INCLUDING NEGLIGENCE), STRICT LIABILITY OR OTHERWISE, EVEN IFAPPLE HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.Copyright (C) 2008 Apple Inc. All Rights Reserved.*/#import <OpenGLES/ES1/glext.h>#import "Texture2D.h"void checkGLError() {		int err = glGetError();			const char* RVAL = "GL_UNKNOWN_ERROR";		switch( err )	{		case GL_NO_ERROR:			RVAL =  "GL_NO_ERROR";			break;		case GL_INVALID_ENUM:			RVAL =  "GL_INVALID_ENUM";			break;		case GL_INVALID_VALUE:			RVAL =  "GL_INVALID_VALUE";			break;		case GL_INVALID_OPERATION:			RVAL = "GL_INVALID_OPERATION";			break;		case GL_STACK_OVERFLOW:			RVAL =  "GL_STACK_OVERFLOW";			break;		case GL_STACK_UNDERFLOW:			RVAL =  "GL_STACK_UNDERFLOW";			break;		case GL_OUT_OF_MEMORY:			RVAL =  "GL_OUT_OF_MEMORY";			break;		default:			break;	}		if( err != GL_NO_ERROR ) {		printf("GL_ERROR: %s\n", RVAL );		assert(0);	}}//CONSTANTS:#define kMaxTextureSize	 1024//CLASS IMPLEMENTATIONS:static GLuint nFbo = 0;@interface Texture2D (private)- (void) setName:(GLuint)name;- (id) initParametersPixelFormat:(Texture2DPixelFormat)pixelFormat pixelsWide:(NSUInteger)width pixelsHigh:(NSUInteger)height contentSize:(CGSize)size;@end@implementation Texture2D@synthesize contentSize=_size, pixelFormat=_format, pixelsWide=_width, pixelsHigh=_height, name=_name, maxS=_maxS, maxT=_maxT;- (id) initWithData:(const void*)data pixelFormat:(Texture2DPixelFormat)pixelFormat pixelsWide:(NSUInteger)width pixelsHigh:(NSUInteger)height contentSize:(CGSize)size{	if (nFbo == 0 ) {		glGenFramebuffersOES( 1, &nFbo);	}		GLint					saveName;	if((self = [super init])) {		glGenTextures(1, &_name);		glGetIntegerv(GL_TEXTURE_BINDING_2D, &saveName);		glBindTexture(GL_TEXTURE_2D, _name);		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);		switch(pixelFormat) {						case kTexture2DPixelFormat_RGBA8888:				glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);				break;			case kTexture2DPixelFormat_RGB565:				glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, width, height, 0, GL_RGB, GL_UNSIGNED_SHORT_5_6_5, data);				break;			case kTexture2DPixelFormat_A8:				glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, width, height, 0, GL_ALPHA, GL_UNSIGNED_BYTE, data);				break;			default:				[NSException raise:NSInternalInconsistencyException format:@""];					}		glBindTexture(GL_TEXTURE_2D, saveName);			_size = size;		_width = width;		_height = height;		_format = pixelFormat;		_maxS = size.width / (float)width;		_maxT = size.height / (float)height;	}						return self;}- (id) initParametersPixelFormat:(Texture2DPixelFormat)pixelFormat pixelsWide:(NSUInteger)width pixelsHigh:(NSUInteger)height contentSize:(CGSize)size {	if((self = [super init])) {		_size = size;		_width = width;		_height = height;		_format = pixelFormat;		_maxS = size.width / (float)width;		_maxT = size.height / (float)height;	}		return self;}- (void) setName:(GLuint)name {	_name = name;}- (id)copyWithZone:(NSZone *)zone {	// create a new texture and do a nothing init	Texture2D* copy = [[[self class] allocWithZone:zone] initParametersPixelFormat:_format pixelsWide:_width pixelsHigh:_height contentSize:_size];		// copy the texture using FBO (see: http://codereflect.com/2008/12/04/duplicating-an-opengl-texture/ )//	GLuint CopyTexture1( GLuint nTexID_in, GLsizei width, GLsizei height )	{		GLint saveName;		GLuint nTexID_out = 0;		// Create the duplicate texture		glGenTextures( 1, &nTexID_out);		glGetIntegerv(GL_TEXTURE_BINDING_2D, &saveName);		glBindTexture( GL_TEXTURE_2D, nTexID_out );		glTexParameteri( GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER, GL_LINEAR );		glTexParameteri( GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER, GL_LINEAR );		// allocate memory for the texture		unsigned char* data = 0;		switch(_format) {							case kTexture2DPixelFormat_RGBA8888:				data = malloc( _width * _height * 4 );				memset( data, 0, _width * _height * 4 );				glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, _width, _height, 0, GL_RGBA, GL_UNSIGNED_BYTE, data);				break;			case kTexture2DPixelFormat_RGB565:				data = malloc( _width * _height * 2 );				memset( data, 0, _width * _height * 2 );				glTexImage2D(GL_TEXTURE_2D, 0, GL_RGB, _width, _height, 0, GL_RGB, GL_UNSIGNED_SHORT_5_6_5, data);				break;			case kTexture2DPixelFormat_A8:				data = malloc( _width * _height * 1 );				memset( data, 0, _width * _height * 1 );				glTexImage2D(GL_TEXTURE_2D, 0, GL_ALPHA, _width, _height, 0, GL_ALPHA, GL_UNSIGNED_BYTE, data);				break;			default:				[NSException raise:NSInternalInconsistencyException format:@""];						}				if ( data ) {			free( data );			data = 0;		}				// bind frame buffer		glBindFramebufferOES( GL_FRAMEBUFFER_OES, nFbo);		glFramebufferTexture2DOES( GL_FRAMEBUFFER_OES, GL_COLOR_ATTACHMENT0_OES, GL_TEXTURE_2D, nTexID_out, 0 );		{			CGRect rect = CGRectMake(0, 0, _width, _height);			// get viewport to restore back when we are done			GLint viewport[4];			GLfloat projection[16];			glGetIntegerv( GL_VIEWPORT, viewport );			glGetFloatv( GL_PROJECTION_MATRIX, projection );			glMatrixMode( GL_PROJECTION );			glLoadIdentity();			glOrthof(0, _width, 0, _height, -1, 1);			glViewport( 0, 0, _width, _height );			glMatrixMode( GL_MODELVIEW );						// setup the vertices			GLfloat	 coordinates[] = {  0,	0,										1,	0,										0,	1,										1,	1  };			GLfloat	vertices[] = {	rect.origin.x,							rect.origin.y,							0.0,									rect.origin.x + rect.size.width,		rect.origin.y,							0.0,									rect.origin.x,							rect.origin.y + rect.size.height,		0.0,									rect.origin.x + rect.size.width,		rect.origin.y + rect.size.height,		0.0 };									glEnable(GL_TEXTURE_2D);			glDisable(GL_BLEND);			glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);						glEnableClientState(GL_VERTEX_ARRAY);			glEnableClientState(GL_TEXTURE_COORD_ARRAY);						glBindTexture(GL_TEXTURE_2D, _name);			glVertexPointer(3, GL_FLOAT, 0, vertices);			glTexCoordPointer(2, GL_FLOAT, 0, coordinates);			glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);						// restore the old viewport			glMatrixMode( GL_PROJECTION );			glLoadMatrixf( projection );			glViewport( viewport[0], viewport[1], viewport[2], viewport[3] );			glMatrixMode( GL_MODELVIEW );								}		glBindFramebufferOES( GL_FRAMEBUFFER_OES, 0 );				glBindTexture(GL_TEXTURE_2D, saveName);		[copy setName:nTexID_out];			}			// Do the cleanup		return copy;}- (void) dealloc{	if(_name)	 glDeleteTextures(1, &_name);		[super dealloc];}- (NSString*) description{	return [NSString stringWithFormat:@"<%@ = %08X | Name = %i | Dimensions = %ix%i | Coordinates = (%.2f, %.2f)>", [self class], self, _name, _width, _height, _maxS, _maxT];}@end@implementation Texture2D (Image)	- (id) initWithImage:(UIImage *)uiImage{	NSUInteger				width,							height,							i;	CGContextRef			context = nil;	void*					data = nil;	CGColorSpaceRef			colorSpace;	void*					tempData;	unsigned int*			inPixel32;	unsigned short*			outPixel16;	BOOL					hasAlpha;	CGImageAlphaInfo		info;	CGAffineTransform		transform;	CGSize					imageSize;	Texture2DPixelFormat    pixelFormat;	CGImageRef				image;	UIImageOrientation		orientation;	BOOL					sizeToFit = NO;			image = [uiImage CGImage];	orientation = [uiImage imageOrientation]; 		if(image == NULL) {		[self release];		NSLog(@"Image is Null");		return nil;	}		info = CGImageGetAlphaInfo(image);	hasAlpha = ((info == kCGImageAlphaPremultipliedLast) || (info == kCGImageAlphaPremultipliedFirst) || (info == kCGImageAlphaLast) || (info == kCGImageAlphaFirst) ? YES : NO);	if(CGImageGetColorSpace(image)) {		if(hasAlpha)			pixelFormat = kTexture2DPixelFormat_RGBA8888;		else			pixelFormat = kTexture2DPixelFormat_RGB565;	} else  //NOTE: No colorspace means a mask image		pixelFormat = kTexture2DPixelFormat_A8;			imageSize = CGSizeMake(CGImageGetWidth(image), CGImageGetHeight(image));	transform = CGAffineTransformIdentity;	width = imageSize.width;		if((width != 1) && (width & (width - 1))) {		i = 1;		while((sizeToFit ? 2 * i : i) < width)			i *= 2;		width = i;	}	height = imageSize.height;	if((height != 1) && (height & (height - 1))) {		i = 1;		while((sizeToFit ? 2 * i : i) < height)			i *= 2;		height = i;	}	while((width > kMaxTextureSize) || (height > kMaxTextureSize)) {		width /= 2;		height /= 2;		transform = CGAffineTransformScale(transform, 0.5, 0.5);		imageSize.width *= 0.5;		imageSize.height *= 0.5;	}		//colorSpace = CGImageGetColorSpace(image);		switch(pixelFormat) {				case kTexture2DPixelFormat_RGBA8888:			colorSpace = CGColorSpaceCreateDeviceRGB();			data = malloc(height * width * 4);			context = CGBitmapContextCreate(data, width, height, 8, 4 * width, colorSpace, kCGImageAlphaPremultipliedLast | kCGBitmapByteOrder32Big);			CGColorSpaceRelease(colorSpace);			break;		case kTexture2DPixelFormat_RGB565:			colorSpace = CGColorSpaceCreateDeviceRGB();			data = malloc(height * width * 4);			context = CGBitmapContextCreate(data, width, height, 8, 4 * width, colorSpace, kCGImageAlphaNoneSkipLast | kCGBitmapByteOrder32Big);			CGColorSpaceRelease(colorSpace);			break;					case kTexture2DPixelFormat_A8:			data = malloc(height * width);			context = CGBitmapContextCreate(data, width, height, 8, width, NULL, kCGImageAlphaOnly);			break;						default:			[NSException raise:NSInternalInconsistencyException format:@"Invalid pixel format"];	} 	CGContextClearRect(context, CGRectMake(0, 0, width, height));	CGContextTranslateCTM(context, 0, height - imageSize.height);		if(!CGAffineTransformIsIdentity(transform))		CGContextConcatCTM(context, transform);	CGContextDrawImage(context, CGRectMake(0, 0, CGImageGetWidth(image), CGImageGetHeight(image)), image);	//Convert "RRRRRRRRRGGGGGGGGBBBBBBBBAAAAAAAA" to "RRRRRGGGGGGBBBBB"	if(pixelFormat == kTexture2DPixelFormat_RGB565) {		tempData = malloc(height * width * 2);		inPixel32 = (unsigned int*)data;		outPixel16 = (unsigned short*)tempData;		for(i = 0; i < width * height; ++i, ++inPixel32)			*outPixel16++ = ((((*inPixel32 >> 0) & 0xFF) >> 3) << 11) | ((((*inPixel32 >> 8) & 0xFF) >> 2) << 5) | ((((*inPixel32 >> 16) & 0xFF) >> 3) << 0);		free(data);		data = tempData;			}	self = [self initWithData:data pixelFormat:pixelFormat pixelsWide:width pixelsHigh:height contentSize:imageSize];		CGContextRelease(context);	free(data);		return self;}@end@implementation Texture2D (Text)- (id) initWithString:(NSString*)string dimensions:(CGSize)dimensions alignment:(UITextAlignment)alignment fontName:(NSString*)name fontSize:(CGFloat)size{	NSUInteger				width,							height,							i;	CGContextRef			context;	void*					data;	CGColorSpaceRef			colorSpace;	UIFont *				font;		font = [UIFont fontWithName:name size:size];		width = dimensions.width;	if((width != 1) && (width & (width - 1))) {		i = 1;		while(i < width)		i *= 2;		width = i;	}	height = dimensions.height;	if((height != 1) && (height & (height - 1))) {		i = 1;		while(i < height)		i *= 2;		height = i;	}		colorSpace = CGColorSpaceCreateDeviceGray();	data = calloc(height, width);	context = CGBitmapContextCreate(data, width, height, 8, width, colorSpace, kCGImageAlphaNone);	CGColorSpaceRelease(colorSpace);			CGContextSetGrayFillColor(context, 1.0, 1.0);	CGContextTranslateCTM(context, 0.0, height);	CGContextScaleCTM(context, 1.0, -1.0); //NOTE: NSString draws in UIKit referential i.e. renders upside-down compared to CGBitmapContext referential	UIGraphicsPushContext(context);		[string drawInRect:CGRectMake(0, 0, dimensions.width, dimensions.height) withFont:font lineBreakMode:UILineBreakModeWordWrap alignment:alignment];	UIGraphicsPopContext();		self = [self initWithData:data pixelFormat:kTexture2DPixelFormat_A8 pixelsWide:width pixelsHigh:height contentSize:dimensions];		CGContextRelease(context);	free(data);		return self;}@end@implementation Texture2D (Drawing)- (void) drawAtPoint:(CGPoint)point {	GLfloat		coordinates[] = { 0,	_maxT,								_maxS,	_maxT,								0,		0,								_maxS,	0 };	GLfloat		width = (GLfloat)_width * _maxS,				height = (GLfloat)_height * _maxT;	GLfloat		vertices[] = {	-width / 2 + point.x,	-height / 2 + point.y,	0.0,								width / 2 + point.x,	-height / 2 + point.y,	0.0,								-width / 2 + point.x,	height / 2 + point.y,	0.0,								width / 2 + point.x,	height / 2 + point.y,	0.0 };		glEnable(GL_TEXTURE_2D);	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);	glEnableClientState(GL_VERTEX_ARRAY);	glEnableClientState(GL_TEXTURE_COORD_ARRAY);		glBindTexture(GL_TEXTURE_2D, _name);	glVertexPointer(3, GL_FLOAT, 0, vertices);	glTexCoordPointer(2, GL_FLOAT, 0, coordinates);	glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);}- (void) drawAtPoint:(CGPoint)point srcEnum:(GLenum)srcEnum dstEnum:(GLenum)dstEnum {	GLfloat		coordinates[] = { 0,	_maxT,								_maxS,	_maxT,								0,		0,								_maxS,	0 };	GLfloat		width = (GLfloat)_width * _maxS,				height = (GLfloat)_height * _maxT;	GLfloat		vertices[] = {	-width / 2 + point.x,	-height / 2 + point.y,	0.0,								width / 2 + point.x,	-height / 2 + point.y,	0.0,								-width / 2 + point.x,	height / 2 + point.y,	0.0,								width / 2 + point.x,	height / 2 + point.y,	0.0 };		glEnable(GL_TEXTURE_2D);	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);	glEnableClientState(GL_VERTEX_ARRAY);	glEnableClientState(GL_TEXTURE_COORD_ARRAY);		glBlendFunc(srcEnum, dstEnum);	glBindTexture(GL_TEXTURE_2D, _name);	glVertexPointer(3, GL_FLOAT, 0, vertices);	glTexCoordPointer(2, GL_FLOAT, 0, coordinates);	glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);}- (void) drawInRect:(CGRect)rect textureEnvironment:(GLint)environment flipY:(BOOL)flipY {	GLfloat	 coordinates[] = {  0,		_maxT,								_maxS,	_maxT,								0,		0,								_maxS,	0  };	if ( flipY == YES ) {		coordinates[1] = 0;		coordinates[3] = 0;		coordinates[5] = _maxT;		coordinates[7] = _maxT;	}									GLfloat	vertices[] = {	rect.origin.x,							rect.origin.y,							0.0,							rect.origin.x + rect.size.width,		rect.origin.y,							0.0,							rect.origin.x,							rect.origin.y + rect.size.height,		0.0,							rect.origin.x + rect.size.width,		rect.origin.y + rect.size.height,		0.0 };		glEnable(GL_TEXTURE_2D);	glDisable(GL_BLEND);//	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);//	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, environment);	// GL_REPLACE is usually the default	glEnableClientState(GL_VERTEX_ARRAY);	glEnableClientState(GL_TEXTURE_COORD_ARRAY);		glBindTexture(GL_TEXTURE_2D, _name);	glVertexPointer(3, GL_FLOAT, 0, vertices);	glTexCoordPointer(2, GL_FLOAT, 0, coordinates);	glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);}- (void) drawInRect:(CGRect)rect srcEnum:(GLenum)srcEnum dstEnum:(GLenum)dstEnum textureEnvironment:(GLint)environment flipY:(BOOL)flipY {	CHECK_GL_ERROR;		GLfloat	 coordinates[] = {  0,		_maxT,								_maxS,	_maxT,								0,		0,								_maxS,	0  };									if ( flipY == YES ) {		coordinates[1] = 0;		coordinates[3] = 0;		coordinates[5] = _maxT;		coordinates[7] = _maxT;	}									GLfloat	vertices[] = {	rect.origin.x,							rect.origin.y,							0.0,							rect.origin.x + rect.size.width,		rect.origin.y,							0.0,							rect.origin.x,							rect.origin.y + rect.size.height,		0.0,							rect.origin.x + rect.size.width,		rect.origin.y + rect.size.height,		0.0 };		glEnable(GL_TEXTURE_2D);	glEnable(GL_BLEND);	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, environment);	glEnableClientState(GL_VERTEX_ARRAY);	glEnableClientState(GL_TEXTURE_COORD_ARRAY);		glBlendFunc(srcEnum, dstEnum);	glBindTexture(GL_TEXTURE_2D, _name);	glVertexPointer(3, GL_FLOAT, 0, vertices);	glTexCoordPointer(2, GL_FLOAT, 0, coordinates);	CHECK_GL_ERROR;	glDrawArrays(GL_TRIANGLE_STRIP, 0, 4);		CHECK_GL_ERROR;	}- (void) paintTextureFromPoint:(CGPoint)pointA toPoint:(CGPoint)pointB {	static GLfloat *vertices = NULL;	int count, i, diffX, diffY;	GLfloat colors[4];		glEnable(GL_TEXTURE_2D);	glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);	glEnableClientState(GL_VERTEX_ARRAY);	glDisableClientState(GL_TEXTURE_COORD_ARRAY);		glEnable(GL_BLEND);	glBindTexture(GL_TEXTURE_2D, _name);		glEnable(GL_POINT_SPRITE_OES);	glTexEnvf(GL_POINT_SPRITE_OES, GL_COORD_REPLACE_OES, GL_TRUE);	glPointSize(_width / kBrushScale);		// Draw the black section on the bottom (pre-paint)	glGetFloatv(GL_CURRENT_COLOR, &colors[0]);		//Allocate vertex array buffer	if(vertices == NULL) {		vertices = malloc(2 * sizeof(GLfloat));	}		//Add points to the buffer so there are drawing points every X pixels	diffX = pointB.x - pointA.x;	diffY = pointB.y - pointA.y;		count = MAX(ceilf(sqrtf(diffX * diffX + diffY * diffY) / kBrushPixelStep), 1);		/*	if (abs(diffX) > abs(diffY)) {		count = MAX(ceilf(abs(diffX) / kBrushPixelStep), 1);	} else {		count = MAX(ceilf(abs(diffY) / kBrushPixelStep), 1);	}	*/		for(i = 0; i < count; ++i) {		vertices[0] = pointA.x + diffX * ((GLfloat)i / (GLfloat)count);		vertices[1] = pointA.y + diffY * ((GLfloat)i / (GLfloat)count);				glBlendFunc(GL_ZERO, GL_ONE_MINUS_SRC_COLOR);		glColor4f(1.0,1.0,1.0,1.0);		//Render the vertex array		glVertexPointer(2, GL_FLOAT, 0, vertices);		glDrawArrays(GL_POINTS, 0, 1);				glColor4f(colors[0], colors[1], colors[2], 1.0);		// Set a blending function to use		glBlendFunc(GL_SRC_ALPHA, GL_ONE);				//Render the vertex array		glVertexPointer(2, GL_FLOAT, 0, vertices);		glDrawArrays(GL_POINTS, 0, 1);	}	}@end